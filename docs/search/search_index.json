{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Akka Fusion"},{"location":"/index.html#akka-fusion","text":"Akka Fusion可以轻松创建独立的，生产级的基于Akka的应用程序。我们集成了Akka生态系统里常用及流行的组件，可以快速搭建你的应用。\n大多数Akka Fusion应用程序只需要很少的 配置。\n官网：https://ihongka.github.io/akka-fusion/。\nAkka Fusion以Akka工具库为基础，为用户提供开箱及用的微服务、云应用框架。Akka Fusion集成了Scala/Akka社区各种优秀的开源组件， 让你可以快速开始你的微服务开发，就像Spring Boot、Spring Cloud一样。但Akka Fusion更加强大、易用、安全， 它具有完备的编译期检查，让你在开发阶段即可排除更多的错误。","title":"Akka Fusion"},{"location":"/index.html#快速开始","text":"代码：\nobject SampleApplication {\n\n  def main(args: Array[String]): Unit = {\n    implicit val system = ActorSystem()\n    implicit val ec     = system.dispatcher\n    val sampleService   = new SampleService()\n    val routes          = new SampleRoute(sampleService)\n    FusionHttpServer(system).component.startRouteSync(routes.route)\n  }\n}\n\n// Controller\nclass SampleRoute(sampleService: SampleService) extends AbstractRoute {\n  override def route: Route = pathGet(\"hello\") {\n    parameters(('hello, 'year.as[Int].?(2019))).as(SampleReq) { req =>\n      futureComplete(sampleService.hello(req))\n    }\n  }\n}\n\n// Request、Response Model\ncase class SampleReq(hello: String, year: Int)\ncase class SampleResp(hello: String, year: Int, language: String)\n\n// Service\nclass SampleService()(implicit ec: ExecutionContext) {\n\n  def hello(req: SampleReq): Future[SampleResp] = Future {\n    SampleResp(req.hello, req.year, \"scala\")\n  }\n}\n测试：\n$ curl -i http://localhost:8000/hello?hello=Hello\nHTTP/1.1 200 OK\nFusion-Server: fusion/0:0:0:0:0:0:0:0:8000\nServer: akka-http/10.1.7\nDate: Sat, 16 Feb 2019 11:24:37 GMT\nContent-Type: application/json\nContent-Length: 48\n\n{\"hello\":\"Hello\",\"year\":2019,\"language\":\"scala\"}","title":"快速开始"},{"location":"/index.html#目录","text":"简介 核心 Akka Extension（扩展） Http Route（异步处理器） FusionCore HTTP 开始 管理API Interceptor Chain（拦截器链） 服务注册、发现（Client） 连接 Nacos HTTP网关代理 配置实现 编程实现 完整配置 Jdbc 示例 Slick MyBatis 目录 起步 配置 Data Mongodb Data Kafka 开始 Kafka Producer Kafka Consumer 配置 Fusion Core 配置 Fusion HTTP 配置 Fusion HTTP Gateway 配置 Fusion JDBC 配置 Fusion Slick 配置 Fusion Mybatis 配置 Fusion Mongodb 配置 Fusion Kafka 配置 反应式宣言 2.0","title":"目录"},{"location":"/intro/index.html","text":"","title":"简介"},{"location":"/intro/index.html#简介","text":"关于Akka Fusion（之后在不引起冲突的情况下可简称为Fusion、akka-fusion）。","title":"简介"},{"location":"/core/index.html","text":"","title":"核心"},{"location":"/core/index.html#核心","text":"Akka Extension（扩展） 从配置加载 构建扩展 通过Akka Extension来管理资源 通过Akka Extension来管理服务（依赖） Http Route（异步处理器） RequestContext RouteResult FusionCore shutdowns","title":"核心"},{"location":"/core/akka-extension.html","text":"","title":"Akka Extension（扩展）"},{"location":"/core/akka-extension.html#akka-extension-扩展-","text":"Akka Extension是Akka提供的一套可插拔的、用来增强Akka能力的机制，akka-cluster等很多内建功能也是基于它实现的。同时，Akka Extension还提供了某种程度上的依赖管理功能，Fusion也基于它实现了**akka-fusion**框架的模块化管理。\nAkka Extension提供了两个基本组件：Extension和ExtensionId。每个Akka扩展在同一个ActorSystem内保证只加载一次，你可以选择按需加载，也可以选择随ActorSystem创建时即加载。有关这部分的内容参考接下来的 从配置加载 。\n这样，在你的应用中只需要全局保证一个ActorSystem即可，其它的服务、资源都可以通过 Akka Extension 来维护。同时，你可以很自然的在自己的Akka Extension实例内部引用其它的Akka Extension（需要保证它们都使用同一个ActorSystem）。 这可能是在不使用IOC（如Spring、Guice等）情况下最好的进行依赖管理机制之一。","title":"Akka Extension（扩展）"},{"location":"/core/akka-extension.html#从配置加载","text":"akka {\n  # 用于为Akka制作的第三方扩展库，需要随ActorSystem一起加载。\n  # 若最终用户需要在`application.conf`中配置扩展，应使用`extensions`属性配置。\n  library-extensions = ${?akka.library-extensions} [\"akka.serialization.SerializationExtension\"]\n\n  # 在此列出需要加载的多个自定义扩展，需要使用类的全限定名。\n  extensions = []\n}","title":"从配置加载"},{"location":"/core/akka-extension.html#构建扩展","text":"akka-fusion在提供了 FusionExtension 帮助trait来构建Akka Extension。\ntrait FusionExtension extends Extension {\n  protected val _system: ExtendedActorSystem\n  implicit val system: ActorSystem = _system\n  def configuration: Configuration = FusionCore(system).configuration\n}\nFusionExtension在默认Extension基础之上添加了ActorSystem引用，并通过FusionCore提供了Configuration（对Lightbend Config的增强包装）。","title":"构建扩展"},{"location":"/core/akka-extension.html#通过akka-extension来管理资源","text":"接下来为FusionJdbc作为示例，说明FusionExtension是怎样来管理我们的数据库访问资源的。FusionJdbc管理了一个或多个数据库连接池，连接池通过 HikariCP 实现。\nclass FusionJdbc private (val _system: ExtendedActorSystem) extends FusionExtension {\n  val components = new JdbcComponents(system)\n  FusionCore(system).shutdowns.beforeActorSystemTerminate(\"StopFusionJdbc\") { () =>\n    components.closeAsync()(system.dispatcher)\n  }\n  def component: HikariDataSource = components.component\n}\n\nobject FusionJdbc extends ExtensionId[FusionJdbc] with ExtensionIdProvider {\n  override def createExtension(system: ExtendedActorSystem): FusionJdbc = new FusionJdbc(system)\n  override def lookup(): ExtensionId[_ <: Extension]                    = FusionJdbc\n}\nFusionJdbc将由Akka保证在同一个ActorSystem中只被实例化一次，就像Spring框架里的@Service注解、Guice框架的Singleton注解一样，它们都是 单例 。\nfinal private[jdbc] class JdbcComponents(system: ActorSystem)\n    extends Components[HikariDataSource](JdbcConstants.PATH_DEFAULT) {\n  override def configuration: Configuration = FusionCore(system).configuration\n\n  override protected def componentClose(c: HikariDataSource): Future[Done] = Future.successful {\n    c.close()\n    Done\n  }\n  override protected def createComponent(id: String): HikariDataSource =\n    JdbcUtils.createHikariDataSource(configuration.getConfig(id))\n}\nJdbcComponents继承了Components，Components提供了一个保存同一类型组件的多个实例的优秀方案。它基于 Lightbend Config 实现了可配置化，通过构造函数传入的配置路径（id）来决定引用哪一个配置，并保存id的实例的对应关系。\n请关注FusionCore(system).shutdowns.beforeActorSystemTerminate这行代码，它使用CoordinatedShutdown来协调资源的关闭，它将在ActorSystem终止前关闭所有数据库连接池。更多内容请参阅： FusionCore#shutdowns","title":"通过Akka Extension来管理资源"},{"location":"/core/akka-extension.html#components","text":"Components 提供代码实现如下：\nabstract class Components[T](DEFAULT_ID: String) extends StrictLogging {\n  protected val components = mutable.Map.empty[String, T]\n\n  def configuration: Configuration\n\n  protected def createComponent(id: String): T\n  protected def componentClose(c: T): Future[Done]\n\n  def component: T = lookup(DEFAULT_ID)\n\n  final def lookup(id: String): T = synchronized(lookupComponent(id))\n\n  protected def lookupComponent(id: String): T = components.getOrElseUpdate(id, createComponent(id))\n\n  final def register(id: String, other: T, replaceExists: Boolean = false): T =\n    synchronized(registerComponent(id, other, replaceExists))\n\n  protected def registerComponent(id: String, other: T, replaceExists: Boolean): T = {\n    require(id != DEFAULT_ID, s\"id不能为默认配置ID，$id == $DEFAULT_ID\")\n    val isReplace = configuration.getOrElse(id + \".replace-exists\", replaceExists)\n    components.get(id).foreach {\n      case c if isReplace =>\n        try {\n          Await.ready(componentClose(c), 30.seconds)\n        } catch {\n          case e: Throwable =>\n            logger.error(s\"registerComponent replace exists component 30s timeout error: ${e.toString}；id: $id\", e)\n        }\n        components.remove(id)\n      case _ =>\n        throw new IllegalAccessException(s\"id重复，$id\")\n    }\n    components.put(id, other)\n    other\n  }\n\n  def closeAsync()(implicit ec: ExecutionContext): Future[Done] = synchronized {\n    Future.sequence(components.valuesIterator.map(componentClose).toList).map(_ => Done)\n  }\n\n}","title":"Components"},{"location":"/core/akka-extension.html#通过akka-extension来管理服务-依赖-","text":"修定你有3个服务：\nFileService：统一的文件服务，如提供用户头像链接 UserService：用户服务 LoginService：实现用户登录、注册等业务逻辑\n你可以如下定义3个服务\npackage docs.extension.customservice\n\nimport akka.actor.ExtendedActorSystem\nimport akka.actor.Extension\nimport akka.actor.ExtensionId\nimport akka.actor.ExtensionIdProvider\nimport fusion.core.extension.FusionExtension\nimport helloscala.common.exception.HSUnauthorizedException\nimport helloscala.common.util.DigestUtils\nimport helloscala.common.util.StringUtils\n\nimport scala.concurrent.Future\n\ncase class LoginDTO(account: String, password: String)\ncase class LoginBO(id: String, nickname: String)\ncase class UserBO(id: String, nickname: String, avatarId: String, avatarUrl: String)\ncase class UserDO(id: String, nickname: String, avatarId: String, password: String, salt: String)\n\nclass UserRepository {\n\n  def findByAccount(account: String): Future[UserDO] =\n    Future.successful(UserDO(StringUtils.randomString(24), account, StringUtils.randomString(24), \"password\", \"salt\"))\n\n  def findById(id: String): Future[UserDO] =\n    Future.successful(UserDO(id, \"用户\", StringUtils.randomString(24), \"password\", \"salt\"))\n}\n\nclass FileService private (val _system: ExtendedActorSystem) extends FusionExtension {\n\n  def findUrlById(fileId: String): Future[String] = Future.successful {\n    s\"http://localhost:9999/file/$fileId.png\"\n  }\n}\n\nobject FileService extends ExtensionId[FileService] with ExtensionIdProvider {\n  override def createExtension(system: ExtendedActorSystem): FileService = new FileService(system)\n  override def lookup(): ExtensionId[_ <: Extension]                     = FileService\n}\n\nclass UserService private (val _system: ExtendedActorSystem) extends FusionExtension {\n  import system.dispatcher\n  private val fileService    = FileService(system)\n  private val userRepository = new UserRepository()\n\n  def findBOById(id: String): Future[UserBO] = {\n    userRepository.findById(id).flatMap { user =>\n      fileService.findUrlById(user.avatarId).map { url =>\n        UserBO(user.id, user.nickname, user.avatarId, url)\n      }\n    }\n  }\n\n  def findByAccount(account: String): Future[UserDO] = {\n    userRepository.findByAccount(account)\n  }\n}\n\nobject UserService extends ExtensionId[UserService] with ExtensionIdProvider {\n  override def createExtension(system: ExtendedActorSystem): UserService = new UserService(system)\n  override def lookup(): ExtensionId[_ <: Extension]                     = UserService\n}\n\nclass LoginService private (val _system: ExtendedActorSystem) extends FusionExtension {\n  import system.dispatcher\n  private val userService = UserService(system)\n\n  def login(dto: LoginDTO): Future[LoginBO] = {\n    userService.findByAccount(dto.account).map {\n      case user if user.password == DigestUtils.sha256Hex(dto.password + user.salt) =>\n        LoginBO(user.id, user.nickname)\n      case _ =>\n        throw HSUnauthorizedException(\"密码不匹配\")\n    }\n  }\n}\n\nobject LoginService extends ExtensionId[LoginService] with ExtensionIdProvider {\n  override def createExtension(system: ExtendedActorSystem): LoginService = new LoginService(system)\n  override def lookup(): ExtensionId[_ <: Extension]                      = LoginService\n}\n通过以上代码，你看到了怎样使用Akka Extension来实现服务的依赖管理。所有的服务之间只有一个显示依赖：ActorSystem。因为我们的框架是基于Akka的，所以我们认为显示依赖ActorSystem并不是一个问题。","title":"通过Akka Extension来管理服务（依赖）"},{"location":"/core/http-route.html","text":"","title":"Http Route（异步处理器）"},{"location":"/core/http-route.html#http-route-异步处理器-","text":"type Route = RequestContext => Future[RouteResult]\nFusion基于Akka HTTP实现了HTTP 1.0、1.1和2.0协议的请求响应处理，同时还支持GRPC。Route是RequestContext => Future[RouteResult]的类型定义，从接收到一个请求开始，返回一个异步的HTTP响应。原始的HttpRequest被包裹在一个RequestContext请求上下文中，而响应结果也使用了RouteResult进行封装。","title":"Http Route（异步处理器）"},{"location":"/core/http-route.html#requestcontext","text":"RequestContext的一个典型实现如下：\ntrait RequestContext {\n  val request: HttpRequest\n  val unmatchedPath: Uri.Path\n  implicit def executionContext: ExecutionContextExecutor\n  implicit def materializer: Materializer\n  def log: LoggingAdapter\n  def settings: RoutingSettings\n  def parserSettings: ParserSettings\n  def reconfigure(\n    executionContext: ExecutionContextExecutor = executionContext,\n    materializer:     Materializer             = materializer,\n    log:              LoggingAdapter           = log,\n    settings:         RoutingSettings          = settings): RequestContext\n  def complete(obj: ToResponseMarshallable): Future[RouteResult]\n  def reject(rejections: Rejection*): Future[RouteResult]\n  def redirect(uri: Uri, redirectionType: Redirection): Future[RouteResult]\n  def fail(error: Throwable): Future[RouteResult]\n  // ....\n}\nrequest\n保存了原始的HttpRequest对象。\nunmatchedPath\n保存了当前Akka HTTP Routing层级下还未匹配的路径。如下面的路由定义，在account这一级，请求Uri.Path: /api/v4/account/user/page对应的unmatchedPath保持的未匹配路径为：/user/page。\ncomplete\n请求正常完成时，返回数据通过complete函数来响应。complete函数通过ToResponseMarshallable来决定数据类型该怎么处理（序列化），Akka HTTP默认已提供了大部分数据类型的处理方式，我们可以很方便的对自定义数据实现ToResponseMarshallable。对应JSON类型的数据响应，https://github.com/hseeberger/akka-http-json 是一个很好的起点。\nreject\nreject顾名思义，调用它将拒绝当前请求。它需要传一个或多个实现了Rejection接口的类型。akka-fusion默认的reject处理如下：\ndef rejectionBuilder: Builder =\n  RejectionHandler\n    .newBuilder()\n    .handle {\n      case MissingQueryParamRejection(parameterName) =>\n        complete(jsonEntity(BadRequest, s\"请求参数 '$parameterName' 缺失\"))\n\n      case MissingCookieRejection(cookieName) =>\n        val msg = s\"无效的Cookie: $cookieName\"\n        logger.info(msg)\n        complete(jsonEntity(BadRequest, msg))\n\n      case ForbiddenRejection(message, cause) =>\n        val msg = s\"权限禁止：$message\"\n        logger.warn(msg, cause.orNull)\n        complete(jsonEntity(Forbidden, message))\n\n      case SessionRejection(message, cause) =>\n        val msg = s\"会话认证失败：$message\"\n        logger.warn(msg, cause.orNull)\n        complete(jsonEntity(Unauthorized, msg))\n\n      case AuthorizationFailedRejection =>\n        val msg = \"会话认证失败\"\n        logger.warn(msg)\n        complete(jsonEntity(Unauthorized, msg))\n\n      case ValidationRejection(err, _) =>\n        val msg = \"数据校验失败： \" + err\n        logger.info(msg)\n        complete(jsonEntity(BadRequest, msg))\n    }\n    .handleAll[MethodRejection] { methodRejections =>\n      val description = methodRejections.map(_.supported.name).mkString(\" or \")\n      val msg         = s\"不支持的方法！当前支持：$description!\"\n      logger.info(msg)\n      complete(jsonEntity(MethodNotAllowed, msg))\n    }\n    .handleNotFound {\n      extractUri { uri =>\n        val msg = s\"URI: $uri 路径未找到！\"\n        logger.info(msg)\n        complete(jsonEntity(NotFound, msg))\n      }\n    }\n    .handle {\n      case rejection =>\n        logger.info(rejection.toString)\n        complete(jsonEntity(BadRequest, rejection.toString))\n    }\nredirect\nredirect在你需要向请求方返回重定向响应时使用。它有两个参数：\nuri: Uri：需要生定向的地址 redirectionType: Redirection：HTTP响应状态码，现在可选择的状态码有300到308中的一个\nfail\n返回异常的快捷函数，大多数情况下不需要使用到这个。","title":"RequestContext"},{"location":"/core/http-route.html#routeresult","text":"akka.http.scaladsl.server.RouteResult接口有两个子类（定义类似）：\nfinal case class Complete(response: HttpResponse) extends RouteResult\nfinal case class Rejected(rejections: Seq[Rejection]) extends RouteResult\nComplete很直观了，代表请求已完成（HTTP请求已完成，但业务有可能错误）。\n而Rejected代表请求被拒绝，一般用于HTTP方法不对、URL路径未找到、请求实体过大等情况。","title":"RouteResult"},{"location":"/core/fusion-core.html","text":"","title":"FusionCore"},{"location":"/core/fusion-core.html#fusioncore","text":"FusionCore是akka-fusion的核心Akka Extension。提供了如下主要功能：\nshutdowns：程序关闭钩子 configuration: Lightbend Config增强 events：框架事件注册、回调 runMode：运行状态","title":"FusionCore"},{"location":"/core/fusion-core.html#shutdowns","text":"","title":"shutdowns"},{"location":"/http/index.html","text":"","title":"HTTP"},{"location":"/http/index.html#http","text":"开始 依赖 示例程序 内置API 管理API 健康检测 Fusion系统管理 Interceptor Chain（拦截器链） 应用拦截器链 拦截器示例","title":"HTTP"},{"location":"/http/getting.html","text":"","title":"开始"},{"location":"/http/getting.html#开始","text":"","title":"开始"},{"location":"/http/getting.html#依赖","text":"要使用 Fusion Http，需要在你的项目添加如下依赖：\nsbt libraryDependencies += \"com.helloscala.fusion\" %% \"fusion-http\" % \"1.0.0-beta7\" Maven <dependency>\n  <groupId>com.helloscala.fusion</groupId>\n  <artifactId>fusion-http_2.12</artifactId>\n  <version>1.0.0-beta7</version>\n</dependency> Gradle dependencies {\n  compile group: 'com.helloscala.fusion', name: 'fusion-http_2.12', version: '1.0.0-beta7'\n}","title":"依赖"},{"location":"/http/getting.html#示例程序","text":"编写 src/main/application.conf 配置文件，添加以下配置：\ninclude reference.conf\n创建Scala文件：src/main/scala/docs/http/SampleHttp.scala\nobject SampleHttp extends App with Directives {\n  implicit val system = ActorSystem()\n\n  val route = path(\"hello\") {\n    get {\n      complete(\"Hello，Akka Fusion！\")\n    }\n  }\n  FusionHttpServer(system).component.startRouteSync(route)\n}\n运行object SampleHttp，即可启动一个简单的Fusion HTTP应用。我们可以访问 http://127.0.0.1:8000/hello 来进行测试：\n$ curl -i http://localhost:8000/hello\nHTTP/1.1 200 OK\nFusion-Server: default/0:0:0:0:0:0:0:0:8000\nServer: akka-http/10.1.7\nDate: Thu, 21 Feb 2019 09:42:02 GMT\nContent-Type: text/plain; charset=UTF-8\nContent-Length: 22\n\nHello，Akka Fusion！","title":"示例程序"},{"location":"/http/getting.html#内置api","text":"同时，Fusion HTTP还提供了健库检测和管理功能接口。\n健康检测 $ curl -i http://127.0.0.1:8558/_management/health/alive\nHTTP/1.1 200 OK\nContent-Length: 2\nContent-Type: text/plain; charset=UTF-8\nDate: Thu, 21 Feb 2019 09:52:05 GMT\nKeep-Alive: timeout=38\nServer: akka-http/10.1.7\n\nOK\n 关闭应用 $ curl -i -XPOST http://127.0.0.1:8558/_management/fusion/shutdown\nHTTP/1.1 200 OK\nContent-Length: 62\nContent-Type: application/json\nDate: Thu, 21 Feb 2019 09:52:57 GMT\nKeep-Alive: timeout=38\nServer: akka-http/10.1.7\n\n{\"status\":200,\"message\":\"1 second后开始关闭Fusion系统\"}","title":"内置API"},{"location":"/http/management.html","text":"","title":"管理API"},{"location":"/http/management.html#管理api","text":"","title":"管理API"},{"location":"/http/management.html#健康检测","text":"","title":"健康检测"},{"location":"/http/management.html#fusion系统管理","text":"","title":"Fusion系统管理"},{"location":"/http/interceptor-chain.html","text":"","title":"Interceptor Chain（拦截器链）"},{"location":"/http/interceptor-chain.html#interceptor-chain-拦截器链-","text":"Interceptor Chain在应用开发中是一个很常见的设计模式，Fusion提供了HttpInterceptor接口来支持拦截器链模式。\nScala是一门面向对象和函数式编程相融合的一门语言，在函数式编程中可通过函数的嵌套和各种高级处理来实现拦截器链的功能。","title":"Interceptor Chain（拦截器链）"},{"location":"/http/interceptor-chain.html#应用拦截器链","text":"trait HttpInterceptor {\n    def filter(handler: HttpHandler): HttpHandler\n  }\n\n  def applyHttpInterceptorChain(httpHandler: HttpHandler, filters: Iterable[HttpInterceptor]): HttpHandler = {\n    val duce: HttpHandler = filters.foldLeft(httpHandler) {\n      (h, filter) =>\n//      interceptor.filter(handler)\n//      val result = interceptor.filter(h)\n//      req => result(req).getOrElse(h(req))\n        req =>\n          filter.filter(h).apply(req)\n    }\n    duce\n  }\n在applyHttpInterceptorChain函数中，对拦截器链filters应用foldLeft函数，即可非常优雅的应用每一个拦截器。","title":"应用拦截器链"},{"location":"/http/interceptor-chain.html#拦截器示例","text":"","title":"拦截器示例"},{"location":"/http/interceptor-chain.html#拦截器示例-1-trace","text":"class TraceHttpInterceptor(system: ActorSystem) extends HttpInterceptor {\n  import system.dispatcher\n\n  override def interceptor(route: Route): Route = { ctx =>\n    val req         = ctx.request\n    val traceHeader = RawHeader(\"trace-id\", ObjectId.get().toHexString)\n    val headers     = traceHeader +: req.headers\n    val request     = req.copy(headers = headers)\n    route(ctx.withRequest(request)).map {\n      case RouteResult.Complete(response) => RouteResult.Complete(toTrace(response, traceHeader))\n      case a @ RouteResult.Rejected(_)    => a\n    }\n  }\n\n  private def toTrace(response: HttpResponse, traceHeader: RawHeader): HttpResponse = {\n    val headers = traceHeader +: response.headers\n    response.copy(headers = headers)\n  }\n}\nTraceHttpInterceptor实现了给接收到的HTTP请求添加 trace id 的功能，这在微服务中监控调用链非常有用。","title":"拦截器示例 1：trace"},{"location":"/http/interceptor-chain.html#拦截器示例-2-不做任务处理","text":"class NothingHttpInterceptor extends HttpInterceptor {\n  override def interceptor(route: Route): Route = { ctx =>\n    route(ctx)\n  }\n}\n直接返回handler，并不对HTTP请求过程做任务处理，就像 NothingHttpIntercepter 那样。你可以加入判断逻辑，","title":"拦截器示例 2：不做任务处理"},{"location":"/http/interceptor-chain.html#拦截器示例-3-终止调用链","text":"某个拦截器想终止调用链的执行，在转换函数中抛出一个异常即可：\nclass TerminationHttpInterceptor extends HttpInterceptor {\n    override def filter(handler: HttpHandler): HttpHandler = { req =>\n      //handler(req).flatMap(resp => Future.failed(HttpResponseException(resp)))\n//      handler(req).map(resp => throw HttpResponseException(resp))\n      throw HttpResponseException(HttpResponse(StatusCodes.InternalServerError))\n    }\n  }","title":"拦截器示例 3：终止调用链"},{"location":"/discovery-client/index.html","text":"","title":"服务注册、发现（Client）"},{"location":"/discovery-client/index.html#服务注册-发现-client-","text":"Fusion提供服务注册、发现功能，当前支持 Nacos。\n连接 Nacos 依赖 开始使用 更多示例","title":"服务注册、发现（Client）"},{"location":"/discovery-client/nacos.html","text":"","title":"连接 Nacos"},{"location":"/discovery-client/nacos.html#连接-nacos","text":"为什么是Nacos？\nNacos真的不错，提供了易用的SDK； 很可能公司已经投资了大量的基于Spring Cloud的产品/实现，而Nacos是Spring Cloud里非常主流的一个服务注册/发现的实现； Akka的扩展性很好，可非常容易的接入Nacos。","title":"连接 Nacos"},{"location":"/discovery-client/nacos.html#依赖","text":"要使用Fusion提供到服务发现、注册客户端功能，需添加以下依赖：\nsbt libraryDependencies += \"com.helloscala.fusion\" %% \"fusion-discovery-client\" % \"1.0.0-beta7\" Maven <dependency>\n  <groupId>com.helloscala.fusion</groupId>\n  <artifactId>fusion-discovery-client_2.12</artifactId>\n  <version>1.0.0-beta7</version>\n</dependency> Gradle dependencies {\n  compile group: 'com.helloscala.fusion', name: 'fusion-discovery-client_2.12', version: '1.0.0-beta7'\n}","title":"依赖"},{"location":"/discovery-client/nacos.html#开始使用","text":"在application.conf配置文件中添加以下配置指定Nacos服务端：\nfusion.discovery {\n  enable = true\n  nacos {\n    serverAddr = \"10.0.5.36:8849\"\n    namespace = \"7bf36554-e291-4789-b5fb-9e515ca58ba0\"\n    dataId = \"hongka.file.app\"\n    group = \"DEFAULT_GROUP\"\n    timeoutMs = 3000\n    serviceName = \"hongka-file-app\"\n  }\n}\n各配置荐含义为：\nenable：启用Fusion Discovery功能，默认值为false nacos.serverAddr：Nacos服务地址 nacos.namespace：Nacos服务命名空间（可选） nacos.dataId：配置ID nacos.group：配置分组 nacos.timeoutMs：获取注册配置时的超时时间（单位：毫秒），默认值为3000 nacos.serviceName：注册到Nacos时的服务端，不指定则使用fusion.name配置","title":"开始使用"},{"location":"/discovery-client/nacos.html#获取配置","text":"添加以上配置以后，通常我们可以使用Configuration.fromDiscovery()来自动从Nacos服务获取配置信息。当未启用fusion-discovery或Nacos连接失败时将使用本地配置。","title":"获取配置"},{"location":"/discovery-client/nacos.html#注册服务到nacos","text":"Fusion提供了Akka扩展：FusionNacos自动实现注册服务到Nacos。使用ActorSystem的实例调用FusionNacos即可，FusionNacos(system)。代码示例如下：\nval configuration = Configuration.fromDiscovery()\nval system = ActorSystem(\"name\", configuration.underlying)\nFusionNacos(system)","title":"注册服务到Nacos"},{"location":"/discovery-client/nacos.html#更多示例","text":"test(\"通过serverAddr地址和namespace直接访问\") {\n    val configService = NacosServiceFactory.configService(\"localhost:8848\", \"5b764784-f457-46fb-96c6-4f086d5d0ce1\")\n    val confStr       = configService.getConfig(\"hongka.file.app\", NacosConstants.DEFAULT_GROUP, 3000)\n    confStr must not be empty\n    val config = ConfigFactory.parseString(confStr).resolve()\n    config.getString(\"fusion.name\") mustBe \"file-local\"\n  }\n\n  test(\"通过Properties访问\") {\n    val props = new Properties()\n    props.put(\"serverAddr\", \"localhost:8848\")\n    props.put(\"namespace\", \"5b764784-f457-46fb-96c6-4f086d5d0ce1\")\n\n    val configService = NacosServiceFactory.configService(props)\n    val confStr       = configService.getConfig(\"hongka.file.app\", NacosConstants.DEFAULT_GROUP, 3000)\n    confStr must not be empty\n    ConfigFactory.invalidateCaches()\n    val config = ConfigFactory.parseString(confStr).resolve()\n    config.getString(\"fusion.name\") mustBe \"file-local\"\n  }\n\n  test(\"尝试发现配置，失败读本地配置\") {\n    val props = sys.props\n    props.put(\"fusion.discovery.enable\", \"true\")\n    props.put(\"fusion.discovery.nacos.serverAddr\", \"123.206.9.104:8849\")\n    props.put(\"fusion.discovery.nacos.namespace\", \"7bf36554-e291-4789-b5fb-9e515ca58ba0\")\n    props.put(\"fusion.discovery.nacos.dataId\", \"hongka.file.app\")\n//    props.put(\"fusion.discovery.nacos.group\", NacosConstants.DEFAULT_GROUP)\n    val configuration = Configuration.fromDiscovery()\n    configuration.getString(\"fusion.name\") mustBe \"file-app\"\n  }\n代码见： NacosServiceFactoryTest.scala 。","title":"更多示例"},{"location":"/http-gateway/index.html","text":"","title":"HTTP网关代理"},{"location":"/http-gateway/index.html#http网关代理","text":"fusion-http-gateway\nfusion-http-gateway基于 Akka HTTP 实现了一个强大的API网关代理功能，可通过 Lightbend Config 进行配置或编码实现。fusion-http-gateway支持对HTTP 1.0、1.1和2.0请求进行代理，同时还支持GRPC（使用HTTP 2实现）。","title":"HTTP网关代理"},{"location":"/http-gateway/index.html#配置实现","text":"fusion-http-gateway的配置主要分两部分（参考了Nginx）：\nupstreams：设置上游服务 locations：指定需要代理的地址","title":"配置实现"},{"location":"/http-gateway/index.html#upstream","text":"upstreams {\n  # upstream服务名\n  account {\n    # 服务名，用于从服务发现机制中获取一个真实的访问地址\n    serviceName = hongka-server-account\n    # 使用Akka Discovery实现服务发现，默认使用 akka.discovery.method 指定的DiscoveryService\n    discoveryMethod = nacos\n    # 静态设置多个上游服务地址，当未指定serviceName时有效\n    //targets = [\"127.0.0.1:8888\", \"hostname.local\"]\n  }\n}","title":"upstream"},{"location":"/http-gateway/index.html#location","text":"locations {\n  # 要代理的地址前部（从URI PATH开头部分匹配）\n  \"/api/v4/platform\" {\n    # upstream服务名\n    upstream = platform\n    # 代理转发地址，未设置同 /api/v4/platform\n    //proxy-to = \"/api/v4/platform\"\n  }\n}","title":"location"},{"location":"/http-gateway/index.html#编程实现","text":"编程实现非常简单，使用常规的Akka HTTP功能即可。对Akka HTTP不熟悉的用户可阅读一本还不错的电子书：《Scala Web 开发——基于Akka HTTP》。","title":"编程实现"},{"location":"/http-gateway/index.html#完整配置","text":"详细配置见： Fusion Http Gateway 配置。","title":"完整配置"},{"location":"/jdbc/index.html","text":"","title":"Jdbc"},{"location":"/jdbc/index.html#jdbc","text":"Akka Fusion基于Akka Extension机制提供了配置化的 HikariDataSource 管理。 同时，提供了 JdbcTemplate 来简化我们的JDBC编程工作。","title":"Jdbc"},{"location":"/jdbc/index.html#示例","text":"配置 src/main/resources/application.conf\nfusion.jdbc {\n  default {\n    poolName = \"hongka\"\n    jdbcUrl = \"jdbc:mysql://localhost:3306/ihongka?useSSL=false&autoReconnect=true\"\n    username = \"devops\"\n    password = \"2019.Devops\"\n    connectionTestQuery = \"select 1;\"\n    maximumPoolSize = 2\n  }\n}\n测试代码\npackage fusion.jdbc\n\nimport java.time.OffsetDateTime\n\nimport akka.actor.ActorSystem\nimport com.zaxxer.hikari.HikariDataSource\nimport fusion.jdbc.util.JdbcUtils\nimport fusion.test.FusionTestFunSuite\nimport org.scalatest.BeforeAndAfterAll\n\nimport scala.concurrent.Await\nimport scala.concurrent.duration.Duration\n\nclass CFile {\n  var fileId: String                  = _\n  var fileSubject: String             = _\n  var fileType: java.lang.Integer     = _\n  var fileUrl: String                 = _\n  var fileCtime: java.lang.Long       = _\n  var tableAutoUptime: OffsetDateTime = _\n  var duration: java.lang.Integer     = _\n  var fileSize: java.lang.Integer     = _\n\n  override def toString =\n    s\"CFile($fileId, $fileSubject, $fileType, $fileUrl, $fileCtime, $tableAutoUptime, $duration, $fileSize)\"\n}\n\nclass JdbcTemplateTest extends FusionTestFunSuite with BeforeAndAfterAll {\n  private val system                       = ActorSystem()\n  private def dataSource: HikariDataSource = FusionJdbc(system).component\n  private def jdbcTemplate                 = JdbcTemplate(dataSource)\n\n  test(\"listForObject\") {\n    val sql =\n      \"select file_id, file_subject, file_type, file_url, file_ctime, table_auto_uptime, duration, file_size from c_file where table_auto_uptime is null or file_size is null limit 50\"\n    val list = jdbcTemplate.listForObject(sql, Nil, JdbcUtils.resultSetToBean[CFile])\n    list.foreach(println)\n    println(list.size)\n    println(\"---------------------\")\n  }\n\n//  test(\"insertOne\") {\n//    val sql  = \"\"\"insert into c_file(file_id, file_subject, file_type, file_url, file_ctime, duration, hash)\n//                |values (?, ?, ?, ?, ?, ?, ?);\"\"\".stripMargin\n//    val hash = DigestUtils.sha256Hex(Random.nextString(12))\n//    val ret =\n//      jdbcTemplate.update(\n//        sql,\n//        List(hash, \"subject\", 3, s\"/${hash.take(2)}/$hash\", System.currentTimeMillis(), 23432, hash))\n//    ret mustBe 1\n//  }\n\n//  test(\"selectAll\") {\n//    //中华人民共和国\n//    val list = jdbcTemplate.listForMap(\"select * from c_file order by file_ctime desc\", Nil)\n//    list must not be empty\n//    list.foreach(println)\n//  }\n\n  override protected def afterAll(): Unit = {\n    system.terminate()\n    Await.ready(system.whenTerminated, Duration.Inf)\n  }\n\n}","title":"示例"},{"location":"/slick/index.html","text":"","title":"Slick"},{"location":"/slick/index.html#slick","text":"","title":"Slick"},{"location":"/mybatis/index.html","text":"","title":"MyBatis"},{"location":"/mybatis/index.html#mybatis","text":"fusion-mybatis 提供了对 MyBatis SqlSessionFactory 的管理功能，它依赖 fusion-jdbc 组件。\nfusion-mybatis 集成了 Mybatis-plus，对于刚从Java，特别是Spring过来的朋友来说可以更快速的使用Akka来实现自己的业务。","title":"MyBatis"},{"location":"/mybatis/index.html#目录","text":"起步 依赖 示例 配置","title":"目录"},{"location":"/mybatis/getting.html","text":"","title":"起步"},{"location":"/mybatis/getting.html#起步","text":"","title":"起步"},{"location":"/mybatis/getting.html#依赖","text":"sbt libraryDependencies += \"com.helloscala.fusion\" %% \"fusion-mybatis\" % \"1.0.0-beta7\" Maven <dependency>\n  <groupId>com.helloscala.fusion</groupId>\n  <artifactId>fusion-mybatis_2.12</artifactId>\n  <version>1.0.0-beta7</version>\n</dependency> Gradle dependencies {\n  compile group: 'com.helloscala.fusion', name: 'fusion-mybatis_2.12', version: '1.0.0-beta7'\n}","title":"依赖"},{"location":"/mybatis/getting.html#示例","text":"FusionMyBatisTest 演示了一个典型的 MyBatis 数据库操作。\nclass FusionMybatisTest extends TestKit(ActorSystem(\"fusion-mybatis\")) with FusionTestFunSuite {\n\n  test(\"testSqlSession\") {\n    val sqlSessionFactory = FusionMybatis(system).component\n    sqlSessionFactory must not be null\n\n    // auto commit is false\n    val session = sqlSessionFactory.openSession()\n    try {\n      session must not be null\n    } finally {\n      session.close()\n    }\n  }\n\n  test(\"file insert\") {\n    val sqlSessionFactory = FusionMybatis(system).component\n\n    // using函数将自动提交/回滚（异常抛出时）\n    sqlSessionFactory.transactional { session =>\n      val fileMapper = session.getMapper(classOf[FileMapper])\n      val file       = CFile(\"file_id\", \"文件\", \"/32/234242.jpg\", 98234)\n      fileMapper.insert(file)\n//      session.commit()\n//      throw new SQLException()\n    }\n  }\n\n  test(\"file list\") {\n    val sqlSessionFactory = FusionMybatis(system).component\n    sqlSessionFactory.transactional { session =>\n      val fileMapper = session.getMapper(classOf[FileMapper])\n      val list       = fileMapper.list(10)\n      list.forEach(new Consumer[CFile] {\n        override def accept(t: CFile): Unit = println(t)\n      })\n      list must not be empty\n    }\n  }\n\n  test(\"file page\") {\n    val sqlSessionFactory = FusionMybatis(system).component\n//    val result = sqlSessionFactory.transactional { session =>\n//      val fileMapper = session.getMapper(classOf[FileMapper])\n//      val req        = new Page[CFile](0, 10)\n//      fileMapper.selectPage(req, null)\n//    }\n    val result = sqlSessionFactory.mapperTransactional[FileMapper, IPage[CFile]] { fileMapper =>\n      val req = new Page[CFile](0, 10)\n      fileMapper.selectPage(req, null)\n    }\n    result.getRecords must not be empty\n    result.getRecords.forEach(new Consumer[CFile] {\n      override def accept(t: CFile): Unit = println(t)\n    })\n    println(Jackson.prettyStringify(result))\n  }\n\n}\nFileMapper实现了 BaseMapper[T] 接口，它是MyBatis-plus对MyBatis提供的增强：\ntrait FileMapper extends BaseMapper[CFile] {\n  def list(size: Int): java.util.List[CFile]\n}","title":"示例"},{"location":"/mybatis/getting.html#cfile","text":"case class CFile(\n    @BeanProperty var fileId: String = \"\",\n    @BeanProperty var fileSubject: String = \"\",\n    @BeanProperty var fileUrl: String = \"\",\n    @BeanProperty var duration: Int = 0,\n    @BeanProperty var tableAutoUptime: LocalDateTime = LocalDateTime.now())","title":"CFile"},{"location":"/mybatis/getting.html#配置与初始化","text":"application.conf文件中\nfusion.jdbc {\n  default {\n    poolName = \"hongka\"\n    jdbcUrl = \"jdbc:postgresql://localhost:55432/fusion_dev\"\n    username = \"devuser\"\n    password = \"devpass.2019\"\n    connectionTestQuery = \"select 1;\"\n    maximumPoolSize = 2\n    autoCommit = true\n  }\n}\n\nfusion.mybatis {\n  default = {\n    fusion-jdbc-source = fusion.jdbc.default\n    configuration {\n      package-names = [\"fusion.mybatis.mapper\"]\n    }\n  }\n}","title":"配置与初始化"},{"location":"/mybatis/configuration.html","text":"","title":"配置"},{"location":"/mybatis/configuration.html#配置","text":"见： FusionMybatis 。","title":"配置"},{"location":"/data-mongodb/index.html","text":"","title":"Data Mongodb"},{"location":"/data-mongodb/index.html#data-mongodb","text":"","title":"Data Mongodb"},{"location":"/data-kafka/index.html","text":"","title":"Data Kafka"},{"location":"/data-kafka/index.html#data-kafka","text":"开始 依赖 Kafka Producer Kafka Consumer","title":"Data Kafka"},{"location":"/data-kafka/getting.html","text":"","title":"开始"},{"location":"/data-kafka/getting.html#开始","text":"","title":"开始"},{"location":"/data-kafka/getting.html#依赖","text":"sbt libraryDependencies += \"com.helloscala.fusion\" %% \"fusion-kafka\" % \"1.0.0-beta7\" Maven <dependency>\n  <groupId>com.helloscala.fusion</groupId>\n  <artifactId>fusion-kafka_2.12</artifactId>\n  <version>1.0.0-beta7</version>\n</dependency> Gradle dependencies {\n  compile group: 'com.helloscala.fusion', name: 'fusion-kafka_2.12', version: '1.0.0-beta7'\n}","title":"依赖"},{"location":"/data-kafka/producer.html","text":"","title":"Kafka Producer"},{"location":"/data-kafka/producer.html#kafka-producer","text":"","title":"Kafka Producer"},{"location":"/data-kafka/consumer.html","text":"","title":"Kafka Consumer"},{"location":"/data-kafka/consumer.html#kafka-consumer","text":"","title":"Kafka Consumer"},{"location":"/configuration/index.html","text":"","title":"配置"},{"location":"/configuration/index.html#配置","text":"Fusion Core 配置 Fusion HTTP 配置 Fusion HTTP Gateway 配置 Fusion JDBC 配置 Fusion Slick 配置 Fusion Mybatis 配置 Fusion Mongodb 配置 Fusion Kafka 配置","title":"配置"},{"location":"/configuration/core.html","text":"","title":"Fusion Core 配置"},{"location":"/configuration/core.html#fusion-core-配置","text":"akka {\n  loglevel = INFO\n  stdout-loglevel = INFO\n  loggers = [\"akka.event.slf4j.Slf4jLogger\"]\n  logging-filter = \"akka.event.slf4j.Slf4jLoggingFilter\"\n\n  actor {\n    # Set this to on to enable serialization-bindings defined in\n    # additional-serialization-bindings. Those are by default not included\n    # for backwards compatibility reasons. They are enabled by default if\n    # akka.remote.artery.enabled=on.\n    enable-additional-serialization-bindings = on\n\n    allow-java-serialization = off\n\n    serializers {\n      //java = \"com.twitter.chill.akka.AkkaSerializer\"\n      kryo = \"com.twitter.chill.akka.AkkaSerializer\"\n      //      proto = \"akka.remote.serialization.ProtobufSerializer\"\n    }\n  }\n\n  extensions += fusion.core.extension.FusionCore\n}\nfusion {\n  # Fusion系统名，同时也设置为ActorSystem的name\n  name = \"fusion\"\n  core {\n    trace-key = \"f-trace\"\n  }\n}","title":"Fusion Core 配置"},{"location":"/configuration/http.html","text":"","title":"Fusion HTTP 配置"},{"location":"/configuration/http.html#fusion-http-配置","text":"fusion {\n  http {\n    default {\n      server {\n        host = \"0.0.0.0\"\n        port = 8000\n      }\n      rejection-handler = fusion.http.util.DefaultRejectionHandler\n      exception-handler = fusion.http.util.DefaultExceptionHandler\n      default-interceptor = fusion.http.util.DefaultHttpInterceptor\n      http-interceptors = []\n    }\n    custom-media-types = [\n      \"video/x-wmv;true;notcompressible;wmv\",\n      \"audio/x-m4a;true;notcompressible;m4a\",\n      \"audio/x-flac;true;notcompressible;flac\"\n    ]\n  }\n}\n\nakka.http {\n  client {\n\n  }\n}\n\nakka.management {\n  fusion {\n    # 是否启用 akka.management，默认为false\n    enable = false\n    terminate-timeout = 60s\n  }\n  http {\n    hostname = \"127.0.0.1\"\n    //port = 8559\n    base-path = \"_management\"\n    route-providers += \"fusion.http.management.FusionManagementRoutes\"\n    route-providers += \"akka.management.HealthCheckRoutes\"\n    route-providers-read-only = true\n  }\n  health-checks {\n    readiness-path = \"health/ready\"\n    liveness-path = \"health/alive\"\n  }\n}","title":"Fusion HTTP 配置"},{"location":"/configuration/http-gateway.html","text":"","title":"Fusion HTTP Gateway 配置"},{"location":"/configuration/http-gateway.html#fusion-http-gateway-配置","text":"fusion.gateway.http {\n  default {\n    # 代理默认超时时间\n    timeout = 10.seconds\n\n    # 服务上游配置\n    upstreams {\n      # upstream服务名\n      //account {\n        # 服务名，用于从服务发现机制中获取一个真实的访问地址\n        //serviceName = hongka-server-account\n        # 使用Akka Discovery实现服务发现，默认使用 akka.discovery.method 指定的DiscoveryService\n        //discoveryMethod = nacos\n        # 静态设置多个上游服务地址，当未指定serviceName时有效\n        //targets = [\"127.0.0.1:8888\", \"hostname.local\"]\n      //}\n    }\n\n    // 代理地址\n    locations {\n\n      # 要代理的地址前部（从URI PATH开头部分匹配）\n      //\"/api/v4/platform\" {\n        # upstream服务名\n        //upstream = platform\n        # 代理转发地址，未设置同 /api/v4/platform\n        //proxy-to = \"/api/v4/platform\"\n      //}\n    }\n  }\n\n}","title":"Fusion HTTP Gateway 配置"},{"location":"/configuration/jdbc.html","text":"","title":"Fusion JDBC 配置"},{"location":"/configuration/jdbc.html#fusion-jdbc-配置","text":"fusion.jdbc {\n  default {\n    poolName = \"hongka\"\n    jdbcUrl = \"jdbc:mysql://123.206.9.104:3306/zkhk-new?autoReconnect=true&useUnicode=true&characterEncoding=utf8&serverTimezone=UTC&zeroDateTimeBehavior=convertToNull&useSSL=false\"\n    username = \"root\"\n    password = \"123qwe!@#\"\n    connectionTestQuery = \"select 1;\"\n    maximumPoolSize = 2\n  }\n  pg-primary {\n    poolName = \"pg-primary\"\n    jdbcUrl = \"jdbc:postgresql://10.0.32.37,10.0.32.36/test?reWriteBatchedInserts=true&targetServerType=master\"\n    username = \"devuser\"\n    password = \"devpass.2019\"\n    connectionTestQuery = \"select 1;\"\n    maximumPoolSize = 2\n  }\n  pg-secondaries {\n    poolName = \"pg-secondaries\"\n    jdbcUrl = \"jdbc:postgresql://10.0.32.37,10.0.32.36/test?reWriteBatchedInserts=true&targetServerType=preferSlave&loadBalanceHosts=true&readOnly=true\"\n    username = \"devuser\"\n    password = \"devpass.2019\"\n    connectionTestQuery = \"select 1;\"\n    maximumPoolSize = 2\n  }\n  dddd {\n    poolName = \"dddd\"\n    jdbcUrl = \"jdbc:mysql://mysql-cn-east-2-587f2befe84145d6.rds.jdcloud.com:3306/hongka-account?autoReconnect=true&useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai&zeroDateTimeBehavior=convertToNull&useSSL=false\"\n    username = \"zshkjava\"\n    password = \"Nx6z51J3dB\"\n    connectionTestQuery = \"select 1;\"\n    maximumPoolSize = 2\n  }\n}","title":"Fusion JDBC 配置"},{"location":"/configuration/slick.html","text":"","title":"Fusion Slick 配置"},{"location":"/configuration/slick.html#fusion-slick-配置","text":"TODO","title":"Fusion Slick 配置"},{"location":"/configuration/mybatis.html","text":"","title":"Fusion Mybatis 配置"},{"location":"/configuration/mybatis.html#fusion-mybatis-配置","text":"fusion.mybatis {\n  default = {\n    fusion-jdbc-source = fusion.jdbc.default\n    configuration {\n      package-names = [\"fusion.mybatis.mapper\"]\n    }\n  }\n}\nfusion-mybatis依赖fusion-jdbc，需要通过fusion-jdbc-source配置来指定引用的FusionJdbc，配置如下：\nfusion.jdbc {\n  default {\n    poolName = \"hongka\"\n    jdbcUrl = \"jdbc:postgresql://localhost:55432/fusion_dev\"\n    username = \"devuser\"\n    password = \"devpass.2019\"\n    connectionTestQuery = \"select 1;\"\n    maximumPoolSize = 2\n    autoCommit = true\n  }\n}","title":"Fusion Mybatis 配置"},{"location":"/configuration/mongodb.html","text":"","title":"Fusion Mongodb 配置"},{"location":"/configuration/mongodb.html#fusion-mongodb-配置","text":"fusion.data.mongodb {\n  default {\n    uri = \"mongodb://localhost:27017\"\n  }\n}","title":"Fusion Mongodb 配置"},{"location":"/configuration/kafka.html","text":"","title":"Fusion Kafka 配置"},{"location":"/configuration/kafka.html#fusion-kafka-配置","text":"","title":"Fusion Kafka 配置"},{"location":"/reactivemanifesto.html","text":"","title":"反应式宣言 2.0"},{"location":"/reactivemanifesto.html#反应式宣言-2-0","text":"在此摘录《反应式宣言》全文，原方地址可通过：https://www.reactivemanifesto.org/zh-CN 访问。\n版本 2.0，2014 年 9 月 16 日发布\n在不同领域中深耕的组织都在不约而同地尝试发现相似的软件构建模式。 希望这些系统会更健壮、更具回弹性 、更灵活，也能更好地满足现代化的需求。\n近年来，应用程序的需求已经发生了戏剧性的更改，模式变化也随之而来。仅在几年前， 一个大型应用程序通常拥有数十台服务器、 秒级的响应时间、 数小时的维护时间以及GB级的数据。 而今，应用程序被部署到了形态各异的载体上, 从移动设备到运行着数以千计的多核心处理器的云端集群。 用户期望着毫秒级的响应时间，以及服务100%正常运行（随时可用）。 而数据则以PB计量。 昨日的软件架构已经根本无法满足今天的需求。\n我们相信大家需要一套贯通整个系统的架构设计方案， 而设计中必需要关注的各个角度也已被理清： 我们需要系统具备以下特质：即时响应性（Responsive）、回弹性（Resilient）、弹性（Elastic）以及消息驱动（Message Driven）。 对于这样的系统，我们称之为反应式系统（Reactive System）。\n使用反应式方式构建的反应式系统会更加灵活、松耦合、可伸缩。 这使得它们的开发和调整更加容易。 它们对系统的失败（failure）也更加的包容， 而当失败确实发生时， 它们的应对方案会是得体处理而非混乱无序。 反应式系统具有高度的即时响应性， 为用户提供了高效的互动反馈。\n反应式系统的特质：\n即时响应性：只要有可能， 系统就会及时地做出响应。 即时响应是可用性和实用性的基石， 而更加重要的是，即时响应意味着可以快速地检测到问题并且有效地对其进行处理。 即时响应的系统专注于提供快速而一致的响应时间， 确立可靠的反馈上限， 以提供一致的服务质量。 这种一致的行为转而将简化错误处理、 建立最终用户的信任并促使用户与系统作进一步的互动。 回弹性：系统在出现失败时依然保持即时响应性。 这不仅适用于高可用的、 任务关键型系统——任何不具备回弹性的系统都将会在发生失败之后丢失即时响应性。 回弹性是通过复制、 遏制、 隔离以及委托来实现的。 失败的扩散被遏制在了每个组件内部， 与其他组件相互隔离， 从而确保系统某部分的失败不会危及整个系统，并能独立恢复。 每个组件的恢复都被委托给了另一个（外部的）组件， 此外，在必要时可以通过复制来保证高可用性。 （因此）组件的客户端不再承担组件失败的处理。 弹性： 系统在不断变化的工作负载之下依然保持即时响应性。 反应式系统可以对输入（负载）的速率变化做出反应，比如通过增加或者减少被分配用于服务这些输入（负载）的资源。 这意味着设计上并没有争用点和中央瓶颈， 得以进行组件的分片或者复制， 并在它们之间分布输入（负载）。 通过提供相关的实时性能指标， 反应式系统能支持预测式以及反应式的伸缩算法。 这些系统可以在常规的硬件以及软件平台上实现成本高效的弹性。 消息驱动：反应式系统依赖异步的消息传递，从而确保了松耦合、隔离、位置透明的组件之间有着明确边界。 这一边界还提供了将失败作为消息委托出去的手段。 使用显式的消息传递，可以通过在系统中塑造并监视消息流队列， 并在必要时应用回压， 从而实现负载管理、 弹性以及流量控制。 使用位置透明的消息传递作为通信的手段， 使得跨集群或者在单个主机中使用相同的结构成分和语义来管理失败成为了可能。 非阻塞的通信使得接收者可以只在活动时才消耗资源， 从而减少系统开销。\n大型系统由多个较小型的系统所构成， 因此整体效用取决于它们的构成部分的反应式属性。 这意味着， 反应式系统应用着一些设计原则，使这些属性能在所有级别的规模上生效，而且可组合。世界上各类最大型的系统所依赖的架构都基于这些属性，而且每天都在服务于数十亿人的需求。现在，是时候在系统设计一开始就有意识地应用这些设计原则了， 而不是每次都去重新发现它们。\n签署反应式宣言","title":"反应式宣言 2.0"}]}